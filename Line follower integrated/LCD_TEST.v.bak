module LCD_TEST 
(
	input iCLK,
	input iRST_N,
	input [8:0] H_CENTROID,
	input	[7:0]	V_CENTROID,
	output[7:0]	LCD_DATA,
	output LCD_RW,
	output LCD_EN,
	output LCD_RS
);

/*--------------------------------------------------------------------------------------------------
Variable declaration
--------------------------------------------------------------------------------------------------*/

reg	[7:0]		LUT_INDEX;
reg	[8:0]		LUT_DATA;
reg	[5:0]		mLCD_ST;
reg	[5:0]		mRST_ST;

reg	[24:0]	mDLY;
reg				mLCD_Start;
reg	[7:0]		mLCD_DATA;
reg				mLCD_RS;
reg				ready_for_new_print;

wire				mLCD_Done;

parameter	SELECT_INIT = 	0;
parameter	SELECT_NUM	=	5;
parameter	SELECT_ALT	=	
parameter	LCD_INTIAL	=	0;
parameter	LCD_LINE1	=	5;

parameter	DRM_Start	=	9'h080;		// Instruction to set cursor to start pos
parameter	DRM_End		= 	9'h08F;		// Instruction to set cursor to end pos
parameter	DSP_Reset	=	9'h001;		// Instruction to reset display
parameter	DLY_5ms		=	18'h3FFFE;	// 5.24 ms delay
parameter	DLY_500ms	=  25'h17D7840;// Half second delay

/*--------------------------------------------------------------------------------------------------
Main LCD printing state machine
--------------------------------------------------------------------------------------------------*/

always@(posedge iCLK or negedge iRST_N)
begin
	if(!iRST_N)
	begin
		LUT_INDEX	<=	0;
		mLCD_ST		<=	0;
		mRST_ST		<= 0;
		mDLY			<=	0;
		mLCD_Start	<=	0;
		mLCD_DATA	<=	0;
		mLCD_RS		<=	0;
	end
	else
	begin
	   // Print numbers
		if (LUT_INDEX < LCD_LINE1+6+1)
		begin	
			// Not ready to take new data
			ready_for_new_print <= 0;
			
			case (mLCD_ST)
			// Send current instruction to LCD controller
			0:	begin
					mLCD_DATA		<=	LUT_DATA[7:0];
					mLCD_RS			<=	LUT_DATA[8];
					mLCD_Start		<=	1;
					mLCD_ST			<=	mLCD_ST + 1;
				end
			// Wait for LCD controller to finish
			2:	begin
					if(mLCD_Done)
					begin
						mLCD_Start	<=	0;
						mLCD_ST		<=	mLCD_ST + 1;					
					end
				end
			// Wait 5.24 ms
			3:	begin
					if(mDLY < DLY_5ms)
					mDLY				<=	mDLY + 1;
					else
					begin
						mDLY			<=	0;
						mLCD_ST		<=	mLCD_ST + 1;
					end
				end
			// Move to the next character and go back to the start
			4:	begin
					LUT_INDEX 		<= LUT_INDEX + 1;
					mLCD_ST			<=	0;
				end
			endcase		
		end
		
		
		// Reset display
		else
		begin
			// Ready to take new data
			ready_for_new_print <= 1;
		
			case(mRST_ST)
			// Clear the display (send to LCD controller)
			0:	begin
					mLCD_DATA		<=	DSP_Reset[7:0];
					mLCD_RS			<=	DSP_Reset[8];
					mLCD_Start		<=	1;
					mRST_ST			<=	mRST_ST + 1;
				end
			// Wait for LCD controller to finish
			2: begin
					if (mLCD_Done)
						mLCD_Start	<= 0;
						mRST_ST		<=	mRST_ST + 1;					
					end
			// Wait 5.24 ms
			3: begin
					if (mDLY < DLY_5ms)
						mDLY			<=	mDLY + 1;
					else
					begin
						mDLY			<=	0;
						mRST_ST		<=	mRST_ST + 1;
					end
				end
			// Reset state machine and start printing again
			4: begin
					LUT_INDEX 		<= LCD_LINE1;
					mRST_ST			<= 0;
				end
			endcase					
		end
	end
end

/*--------------------------------------------------------------------------------------------------
Read in new numbers when ready, determine digit values
--------------------------------------------------------------------------------------------------*/

always @(posedge ready_for_new_print)
begin
	h_cen = H_CENTROID;
	v_cen = V_CENTROID;
	
	h_cen_tens = h_cen % 100;
	h_ones = h_cen_tens % 10;
	
	v_cen_tens = v_cen % 100;
	v_ones = v_cen_tens % 10;
	
	h_huns = h_cen >= 100 ? (h_cen - h_cen_tens)/100 : 0;
	h_tens = h_cen_tens >= 10 ? (h_cen_tens - h_ones)/10 : 0;
	
	v_huns = v_cen >= 100 ? (v_cen - v_cen_tens)/100 : 0;
	v_tens = v_cen_tens >= 10 ? (v_cen_tens - v_ones)/10 : 0;
end

/*--------------------------------------------------------------------------------------------------
Determine output to LCD
--------------------------------------------------------------------------------------------------*/

always @(*)
begin
	case(LUT_INDEX)
	//	Initialise :
	LCD_INTIAL+0:	SELECT <= SELECT_INIT+0;
	LCD_INTIAL+1:	SELECT <= SELECT_INIT+1;
	LCD_INTIAL+2:	SELECT <= SELECT_INIT+2;
	LCD_INTIAL+3:	SELECT <= SELECT_INIT+3;
	LCD_INTIAL+4:	SELECT <= SELECT_INIT+4;
	
	// Select numbers
	LCD_LINE1+0:	SELECT <= SELECT_NUM+h_huns;
	LCD_LINE1+1:	SELECT <= SELECT_NUM+h_tens; 
	LCD_LINE1+2:	SELECT <= SELECT_NUM+h_ones; 
	LCD_LINE1+3:	SELECT <= SELECT_ALT; // Write a space
	LCD_LINE1+4:	SELECT <= SELECT_NUM+v_huns; 
	LCD_LINE1+5:	SELECT <= SELECT_NUM+v_tens;
	LCD_LINE1+6:	SELECT <= SELECT_NUM+v_ones;

	default:		   SELECT <= SELECT_INIT+1;
	endcase
end

/*--------------------------------------------------------------------------------------------------
Number selection
--------------------------------------------------------------------------------------------------*/

always @(*)
begin 
	case(SELECT)
	
	SELECT_INIT+0:	LUT_DATA	<=	9'h038;
	SELECT_INIT+1:	LUT_DATA	<=	9'h00C;
	SELECT_INIT+2:	LUT_DATA	<=	DSP_Reset;
	SELECT_INIT+3:	LUT_DATA	<=	9'h006;
	SELECT_INIT+4:	LUT_DATA	<=	DRM_Start;
		
	SELECT_NUM+0:	LUT_DATA	<=	9'h130;
	SELECT_NUM+1:	LUT_DATA	<=	9'h131; 
	SELECT_NUM+2:	LUT_DATA	<=	9'h132; 
	SELECT_NUM+3:	LUT_DATA	<=	9'h133; 
	SELECT_NUM+4:	LUT_DATA	<=	9'h134; 
	SELECT_NUM+5:	LUT_DATA	<=	9'h135;
	SELECT_NUM+6:	LUT_DATA	<=	9'h136;
	SELECT_NUM+7:	LUT_DATA	<=	9'h137;
	SELECT_NUM+8:	LUT_DATA <= 9'h138;
	SELECT_NUM+9:	LUT_DATA <= 9'h139;
	
	SELECT_ALT+0:	LUT_DATA	<=	9'h120;
	
	default : LUT_DATA	<=	9'h00C;
	endcase
end
	


LCD_Controller 		u0	(	//	Host Side
							.iDATA(mLCD_DATA),
							.iRS(mLCD_RS),
							.iStart(mLCD_Start),
							.oDone(mLCD_Done),
							.iCLK(iCLK),
							.iRST_N(iRST_N),
							//	LCD Interface
							.LCD_DATA(LCD_DATA),
							.LCD_RW(LCD_RW),
							.LCD_EN(LCD_EN),
							.LCD_RS(LCD_RS)	);

endmodule